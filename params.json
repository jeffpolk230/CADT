{"name":"CADT","body":"### I heard you liked ADTs, so I put some in your C.\r\nCADT is a preprocessor for generating Haskell-like ADTs in C. For instance, this example ADT definition\r\n\r\n````haskell\r\ndata Expr = Plus { l : int, r : int }\r\n          | Inc { o : int }\r\n````\r\n\r\nlicenses the following C code:\r\n\r\n````c\r\nint evaluate(struct Expr e) {\r\n  switch (e.tag) {\r\n    case Plus: return e.Plus.l + e.Plus.r;\r\n    case Inc:  return e.Inc.o + 1;\r\n  };\r\n\r\n  return -1;\r\n}\r\n\r\nvoid test() {\r\n  struct Expr e1 = Expr.Plus(1,3);\r\n  struct Expr e2 = Expr.Inc(5);\r\n  assert(evaluate(e1) == 4);\r\n  assert(evaluate(e2) == 6);\r\n}\r\n````\r\n\r\n#### Recursive types?\r\nRecursive types are not currently possible with CADT; when I get around to it, they'll have to be implemented with pointers I suppose.\r\n\r\n#### Pattern matching syntax\r\nPatience, I'm working on it. I'm hoping for destructuring by constructor name (as in Haskell). This will eliminate the awkwardness of having to access the union members.\r\n\r\n### How this works\r\nBasically, the above ADT definition compiles down to the following C:\r\n\r\n````c\r\nstruct Expr {\r\n  enum {Plus,Inc} tag;\r\n  union {\r\n    struct {\r\n      int l;\r\n      int r;\r\n    } Plus;\r\n    struct {\r\n      int o;\r\n    } Inc;\r\n  };\r\n};\r\ninline struct Expr Expr__Plus(int l,int r) {\r\n  struct Expr x = {Plus};\r\n  x.Plus.l = l;\r\n  x.Plus.r = r;\r\n  return x;\r\n}\r\ninline struct Expr Expr__Inc(int o) {\r\n  struct Expr x = {Inc};\r\n  x.Inc.o = o;\r\n  return x;\r\n}\r\nconst struct {\r\n  struct Expr (*Plus)(int l,int r);\r\n  struct Expr (*Inc)(int o);\r\n} Expr = {\r\n  .Plus = &Expr__Plus,\r\n  .Inc = &Expr__Inc\r\n};\r\n````","tagline":"A preprocessor for algebraic data types in C, written in Haskell.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}